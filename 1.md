### Структура данных: хеш-таблица

Большинство языков программирования содержат структуру данных, называемых **хеш-таблицей, позволяющей находить данные за постоянное время: О(1)**.

В зависимости от языка эти структуры называются:
- хешами
- картами
- отображениями
- хеш-картами
- словарями
- ассоциативными массивами

Хеш-таблица - это список парных значений. Первый элемент в каждой паре называется КЛЮЧОМ. Второй - ЗНАЧЕНИЕМ.

Итак средняя эффективность ПОИСКА в хеш таблице О(1), так как обычно на это уходит только один шаг. Почему?


### Хеширование

Процесс преобразования символов в числа называется хешированием, а код, который для этого используется - хеш-функцией.
Чтобы хеш-функция была валидной, она должна преобразовывать одну и ту же строку в одно и то же число.

:pushpin: В JavaScript нет готовой хеш-функции

:pushpin: В Python для вычисления хешей можно использовать функцию  `hash()`

![image](https://github.com/user-attachments/assets/c685839c-519e-4b54-bcd0-c4a964cd651f)


**Как хеш-таблица сохраняет новые данные?**

1. Хеш-функция применяется к **ключу**
2. **Значение** помещается у ячейку памяти по **индексу** - результату хеширования ключа

**Поиск в хеш-таблице**

1. При поиске по ключу, сновая хешируется ключ
2. Допустим результат хеширования равен 8: по индексу 8 моментально находится значение.

:warning: **Однонаправленный поиск**
Поиск в хеш-таблице возможен за ОДИН шаг только если известен соответствующий ключ.
При попытке найти значение без его ключа, необходимо проверять все пары ключ-значение и сложность
такого поиска равна O(N).

:warning: **Разрешение коллизий**
Попытка добавить новые данные в уже заполненную ячейку называется коллизией.

Классический подход к разрешению коллизий - **метод цепочек**. При возникновении коллизий вместо того, чтобы
поместить в ячейку какое-то одно значение, компьютер помещает в него ссылку на массив.
Когда компьютер находит ячейку со ссылкой на массив, на процесс поиска могу уйти дополнительные шаги --
компьютеру придется провести линейный поиск в массиве с несколькими значениями. Если по какой-то причине все данные
окажутся в одной ячейке хеш-таблицы, то она ничем не лучше массива. Получается, что в худшем случае 
эффективность поиска в хеш-таблице равна `О(N)`.

### Эффективная хеш-таблица

На эффективность хеш-таблицы влияют три фактора:
- количество храянящихся данных
- число доступных ячеек
- используемая хеш-функция

Например, если много данных и мало ячеек, то из-за большого числа коллизий хеш-таблица потяряет свою эффективность.
В идеале хорошая хеш-функция должна распределять данные по всем доступным ячейкам. Чем лучше распределятся данные,
тем меньше мы получим коллизий. Но помимо предотвращения коллизий важно избегать и чрезмерного использования памяти.

Хорошая хеш-таблица должна достичь **компромисса между предотвращением коллизий и потреблением памяти**.

### JavaScript

Пример хеш-таблицы в JavaScript — это тип данных Object, где вы можете связывать значения свойств объекта с ключами свойств.
Однако `Object` в JavaScript — это особый вид реализации хеш-таблицы по двум причинам:
- Он имеет свойства, добавленные классом `Object`. Введённые вами ключи могут конфликтовать и перезаписывать свойства по умолчанию, унаследованные от класса.
- Размер хеш-таблицы не отслеживается. Вам нужно вручную подсчитывать, сколько свойств было определено, а не унаследовано от прототипа.

В отличие от типа `Object`, `Map` требует использования методов `set()` и `get()` для определения и извлечения пар ключ-значение, которые вы хотите добавить в структуру данных. Также нельзя перезаписать унаследованные свойства Map. 

The specification requires maps to be implemented "that, on average, provide access times that are sublinear on the number of elements in the collection". Therefore, it could be represented internally as a hash table (with O(1) lookup), a search tree (with O(log(N)) lookup), or any other data structure, as long as the complexity is better than O(N).

### :round_pushpin: EcmaScript:
Maps must be implemented **using either hash tables** or other mechanisms that, **on average, provide access times that are sublinear on the number of elements in the collection**.

То есть разные движки могут по-разному имплементировать `Map`, но эффективность поиска в `Map` должна быть от O(1) и лучше, чем O(N).


### Python

```
codes = { 200: 'OK', 301: 'Moved permanently', 401: 'Unauthorized', 404: 'Not found', 500: 'Internal server error'}
print(type(codes)) // outputs class 'dict'
```


   
