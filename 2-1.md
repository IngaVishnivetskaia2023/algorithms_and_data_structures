## Dynamic Programming
In the previous chapter, you learned how to write recursively and how to use recursion to solve some rather complex problems.

While recursion can certainly solve some problems, it can also create new ones if not used properly. In fact, recursion is often the culprit behind some of the slowest categories of Big O, such as `O(2N)`.

The good news, though, is that many of these problems can be avoided. 
In this chapter, you’ll learn how to identify some of the most common speed traps found in recursive code and how to express such algorithms in terms of Big O. 
More important, you’ll learn the techniques to fix these problems.

Here’s some more good news: the techniques found in this chapter are pretty simple. Let’s take a look at how to use these easy but effective methods for turning our recursive nightmares into recursive bliss.

### Unnecessary Recursive Calls
Here’s a recursive function that finds the greatest number from an array:
```
​ 	​function​ max(array) {
​ 	  ​if​ (array.length === 0) { ​return​ ​null​; }
​ 	
​ 	  ​if​ (array.length === 1) { ​return​ array[0]; }
​ 	
​ 	  ​if​ (array[0] > max(array.slice(1))) {
​ 	    ​return​ array[0];
​ 	  } ​else​ {
​ 	    ​return​ max(array.slice(1));
​ 	  }
​ 	}
```


The essence of each recursive call is the comparison of a single number (`array[0]`) to the maximum number from the remainder of the array. 
(To calculate the maximum number from the remainder of the array, we call the very max function we’re in, which is what makes the function recursive.)

We achieve the comparison with a conditional statement. The first half of the conditional statement is as follows:
```
​ 	​if​ (array[0] > max(array.slice(1))) {
​ 	  ​return​ array[0];
​ 	}
```


This snippet says that if the single number (`array[0]`) is greater than what has already been determined to be the maximum number of the rest of the array (`max(array.slice(1))`), then by definition, `array[0]` must be the greatest number, so we return it.

Here is the second half of the conditional statement:
```
​ 	​else​ {
​ 	  ​return​ max(array.slice(1));
​ 	}
```

This second snippet says that if array[0] is not greater than the greatest number from the rest of the array, then the greatest number from the rest of the array must be the greatest number overall, and we return it.

While this code works, it contains a hidden inefficiency. If you look carefully, you’ll note that our code contains the phrase, max(array.slice(1)) twice, once in each half of the conditional statement.

The problem with this is that each time we mention max(array.slice(1)), we trigger an entire avalanche of recursive calls.

Let’s break this down for an example array of [1, 2, 3, 4].

We know that we’re going to start by comparing the 1 with the maximum number of the remaining array, [2, 3, 4]. That, in turn, will compare the 2 against the max of the remaining [3, 4], which in turn will compare the 3 against the [4]. This, too, triggers one more recursive call on the [4] itself, which is the base case.

However, to really see how our code plays out, we’re going to start by analyzing the bottom call and working our way up the call chain.

Let’s begin.

### Max Recursive Walk-Through
When we call max([4]), the function simply returns the number 4. Again, this is because our base case is when the array only contains one element, as dictated by the following line of code:


```
 	​if​ (array.length === 1) {
​ 	  ​return​ array[0];
​ 	}
```

This is pretty straightforward—it’s a single function call:

<img width="900" height="50" alt="image" src="https://github.com/user-attachments/assets/447e6098-7b8b-4c9c-92dc-750b5225acb1" />

Moving up the call chain, let’s see what happens when we call max([3, 4]). In the first half of the conditional statement (if (array[0] > max(array.slice(1)))), we compare the 3 to max([4]). But calling max([4]) is itself a recursive call. The following diagram depicts max([3, 4]) calling max([4]):

<img width="900" height="165" alt="image" src="https://github.com/user-attachments/assets/2fa1b4c8-916c-45d5-aecf-45dc355c939b" />

Note that next to the arrow, we put the label “1st” to indicate that this recursive call was triggered by the first half of the conditional statement within max([3, 4]).

After this step has been completed, our code can now compare the 3 with the result of max([4]). Since the 3 is not greater than that result (4), we trigger the second half of the conditional. (This is the code, return max(array.slice(1)).) In this case, we return max([4]).

But when our code returns max([4]), it triggers the actual function call of max([4]). This is now the second time we’ve triggered the max([4]) call:


<img width="900" height="169" alt="image" src="https://github.com/user-attachments/assets/cfede404-0691-4f4f-942d-0b4138c8efa3" />

As you can see, the function, max([3, 4]) ends up calling max([4]) twice. Of course, we’d rather try to avoid doing this if we don’t have to. If we’ve already computed the result of max([4]) once, why should we call the same function again just to get the same result?

This problem gets a lot worse when we move just one level up the call chain.

Here’s what happens when we call max([2, 3, 4]).

During the first half of the conditional, we compare the 2 against max([3, 4]), which we’ve already determined looks like this:

<img width="900" height="169" alt="image" src="https://github.com/user-attachments/assets/adac3b08-ca87-45ec-a8d7-75805e401416" />


So max([2, 3, 4]) calling max([3, 4]) then, would look like this:

<img width="801" height="254" alt="image" src="https://github.com/user-attachments/assets/267e3c69-50ee-4ce1-b5c0-84748a1f4478" />

But here’s the kicker. This is just for the first half of the conditional of max([2, 3, 4]). For the second half of the conditional, we end up calling max([3, 4]) again:

<img width="801" height="261" alt="image" src="https://github.com/user-attachments/assets/b6f5313e-1b89-498c-8dff-c8b7900fbe35" />

Yikes!

Let’s dare to move to the top of the call chain, calling `max([1, 2, 3, 4])`. When all is said and done, after we call max for both halves of the conditional, we get what is shown in the diagram.

<img width="900" height="278" alt="image" src="https://github.com/user-attachments/assets/e9c2aee9-4a85-4fec-a856-7ba4764b2da9" />

So when we call `max([1, 2, 3, 4])`, we actually end up triggering the max function fifteen times.

We can see this visually by adding the statement, console.log(’RECURSION’) to the beginning of our function:
```
​ 	​function​ max(array) {
​ 	  console.log(​'RECURSION'​);
​ 	
​ 	  ​// remaining code omitted for brevity​
​ 	}

```


When we then run our code, we’ll see the word RECURSION printed to our terminal fifteen times.

Now, we do need some of those calls, but not all of them. We do need to calculate max([4]), for example, but one such function call is enough to get the computed result. But here, we call that function eight times.


### The Little Fix for Big O
Thankfully, there’s an easy way to eliminate all these extra recursive calls. We’ll call max only once within our code, and save the result to a variable:


```
 	​function​ max(array) {
​ 	  ​if​ (array.length === 0) { ​return​ ​null​; }
​ 	
​ 	  ​if​ (array.length === 1) { ​return​ array[0]; }
​ 	
​ 	  ​// Calculate the max of the remainder of the array​
​ 	  ​// and store it inside a variable:​
​ 	  ​const​ maxOfRemainder = max(array.slice(1));
​ 	
​ 	  ​// Comparison of first number against this variable:​
​ 	  ​if​ (array[0] > maxOfRemainder) {
​ 	    ​return​ array[0];
​ 	  } ​else​ {
​ 	    ​return​ maxOfRemainder;
​ 	  }
​ 	}
```

By implementing this simple modification, we end up calling max a mere four times. Try it out yourself by adding the console.log(’RECURSION’) line and running the code.

The trick here is we’re making each necessary function call once and saving the result in a variable so we don’t have to ever call that function again.

The difference in efficiency between our initial function and our ever-so-slightly modified function is stark.


### The Efficiency of Recursion
In our second, improved version of the max function, the function recursively calls itself as many times as there are values in the array. We’d call this O(N).

Up until this point, the cases of O(N) we’ve seen involved loops, with a loop running N times. However, we can apply the same principles of Big O to recursion as well.

As you’ll recall, Big O answers the key question: if there are N data elements, how many steps will the algorithm take?

Since the improved max function runs N times for N values in the array, it has a time complexity of O(N). Even if the function itself contains multiple steps, such as five, its time complexity would be O(5N), which is reduced to O(N).

In the first version, though, the function called itself twice during each run (save for the base case). Let’s see how this plays out for different array sizes.

The following table shows how many times max gets called on arrays of various sizes:

| N Elements | Number of Calls |

| 1 | 1 |

| 2 | 3 |

| 3 | 7 |

| 4 |  15 |

| 5 | 31 |










































































































































