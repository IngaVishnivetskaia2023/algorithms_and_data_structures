### Использование хеш-таблицы в качестве индекса для непарных данных

**Преобразив массив в хеш-таблицу, мы можем перевести алгоритм поиска из категории сложности O(N) в O(1).**

:round_pushpin: Пример задачи: [поиск подмножества в массиве](https://jsfiddle.net/ingavish/5a8rkdoL/1/)

```
/* task: определить является ли массив подмножеством другого массива
например:
['a', 'b', 'c', 'd', 'e', 'f']
['b', 'd', 'f', 'h'] - не подмассив
['a', 'c'] - подмассив
*/

/* Классическоe неоптимальное решение */

const arr1 = ['a', 'b', 'c', 'd', 'e', 'f'];
const arr2 = ['b', 'd', 'f'];

const isSubset = (ar1, ar2) => {
let smallerArray;
let biggerArray;

if (ar1.length < ar2.length) {
  smallerArray = [...ar1];
  biggerArray = [...ar2];
} else {
  biggerArray = [...ar1];
  smallerArray = [...ar2];
}

// перебор значений в меньшем массиве
for (let i = 0; i < smallerArray.length; i++) {
// пока допускаем, что текущего значение по индексу i нет в большем массиве:
  let foundMatchInBigArray = false;
  
  for (let j = 0; j < biggerArray.length; j ++) {
    if (smallerArray[i] === biggerArray[j]) {
      foundMatchInBigArray = true;
      break;
    }
  }
  
  // если текущего значения меньшего массива не нашли в большем
  // значит это не подмассив!!!
  if (!foundMatchInBigArray) {
    return false;
  }
  
}
 // цикл выполнен, значен все значения меньшего есть в большем
 return true;
}

console.log(isSubset(arr1, arr2));
```
