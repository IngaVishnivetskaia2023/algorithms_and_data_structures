### Структуры данных на основе узлов

Структуры данных на основе узлов предполагают новые способы организации данных и доступа к ним,
позволяющие повысить производительность кода.

Связный список - простейшая структура данных на основе узлов.

**Связный список** - это структура данных, которая, как и массив, представлена в виде списка элементов.
При создании массива в памяти выделяется непрерывная группа пустых ячеек для хранения данных приложения.
Найти значение по индексу в массиве возможно за один шаг возможно, поскольку известно, с какого адреса
в памяти начинается массив.
Связные списки работают иначе. Вместо того, чтобы занимать непрерывный блок ячеек в памяти, данные в
связныех списках могут быть распределены по разным ячейкам памяти.
Связанные фрагменты данных, рассредоточенные по всей памяти, называются **узлами**.
Каждый элемент связного списка представлен узлом.

**Каждый узел связного списка** содержит дополнительный фрагмент информации: **адрес памяти следующего узла этого списка** - ссылку.

![image](https://github.com/user-attachments/assets/0bb50a66-de88-4a34-acd2-8546c68fe5ef)

Каждый узел состоит из двух ячеек. Первая содержит фактические данные, вторая служит ссылкой на ячейку памяти,
с которой начинается следующий узел. ССылка конечного узла обозначается как `null`, так как этот узел последний.

Первый узел связного списка называется его головой, а последний - хвостом.

В JavaScript все данные относятся к примитивным или ссылочных типам. Числа и булевы значения хранятся непосредственно в переменных.
Массивы и объекты — это ссылочные типы, которые хранятся в памяти отдельно. Область хранения называется кучей, и в начале работы программы она пуста.

Каждая ячейка в куче — это обычная переменная, которая может хранить одно значение. 
У каждой ячейки есть адрес — ее порядковый номер. 
Когда мы создаем новый массив, интерпретатор JavaScript размещает его в свободном месте кучи и **записывает в переменную адрес массива**.

```
let items = [5, 8, 12, 3];
```

![image](https://github.com/user-attachments/assets/4a4dcdd2-e198-4891-aaa7-351f1639d569)

В самой первой ячейке массива хранится его длина или количество элементов, то есть 4. Затем последовательно хранятся сами значения 5, 8, 12 и 3.
Поскольку элементы массива хранятся последовательно, процессор легко определяет адрес элемента по его порядковому номеру в массиве.

Данные в связном списке хранятся не подряд, а вразброс.
Каждое значение хранится в отдельном объекте, который называется узлом. Помимо значения, объект хранит ссылку на следующий узел списка. 
В самом последнем узле вместо ссылки на следующий элемент хранится значение `null`.

Опишем класс, содержащий значение `(value)` и ссылку на следующий узел `(next)`:

```
class LinkedListNode {
  constructor(value, next) {
    this.value = value;
    this.next = next;
  }
}
```

```
const head = new LinkedListNode(5,
    new LinkedListNode(8,
        new LinkedListNode(12,
           new LinkedListNode(3, null)
        )
    )
);
```

Оператор `new` не только создает объект, но и выделяет для него место в памяти.

![image](https://github.com/user-attachments/assets/7a844b36-4cf8-4140-a41c-4fddac0d8447)

Вся работа со списком производится через ссылку на его первый элемент, так что переменная head — единственное, что нам нужно для реализации алгоритмов.

Поскольку мы пишем на языке JavaScript, который поддерживает объектно-ориентированное программирование, мы объединим поле `head` и все наши функции в один класс. 
При создании нового списка в поле `head` хранится значение `null`, что означает, что список пустой.

В простейшем случае, мы вставляем элемент в пустой список. В самом начале значение поля head равно `null`:

![image](https://github.com/user-attachments/assets/761dc3b9-44e0-4bb8-b3fa-39312c53035e)

После вставки элемента `head` указывает на единственный элемент списка:

![image](https://github.com/user-attachments/assets/556c0a13-4f01-41d4-ac8a-5a1f4bd614ba)

Для нового узла списка в куче были выделены две ячейки, и `head` **указывает на этот узел**. 
Адрес первого узла мы запишем, как `addr(1)`, это позволит нам отличать адреса друг от друга.

После вставки второго узла в начало списка:
![image](https://github.com/user-attachments/assets/266c2bf2-141c-41f6-b19e-07781c31d4f3)

Время добавления узла в начало всегда одно и то же и не зависит от размера списка, поэтому в данном случае речь идет об алгоритмической сложности `O(1)`.

```
class LinkedListNode {
  constructor(item, next) {
    this.item = item;
    this.next = next;
  }
}

class LinkedList {
  head = null;
  
  // prepend adds node to the beginning of list
  prepend(value) {
    console.log('value for new node:', value);
    console.log('link to previous element:', this.head);
    // we save last link for newly created node:
    // because new returns us reference link to object/instance
    this.head = new LinkedListNode(value, this.head);
  }
}

const newList = new LinkedList();
newList.prepend(1);
newList.prepend(2);
newList.prepend(3);
newList.prepend(4);
newList.prepend(5);
```

[Repl](https://jsfiddle.net/ingavish/Lh7ybpgq/21/)








